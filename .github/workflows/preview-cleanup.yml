name: Nightly Preview Cleanup

on:
  schedule:
    - cron: '0 0 * * *'  # Every day at midnight UTC
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run only (true/false)'
        required: false
        default: 'true'

permissions:
  contents: read
  id-token: write

jobs:
  cleanup:
    runs-on: ubuntu-latest
    outputs:
      destroyed_envs: ${{ steps.cleanup-step.outputs.destroyed_envs }}
      dry_run: ${{ steps.cleanup-step.outputs.dry_run }}
      run_mode: ${{ steps.cleanup-step.outputs.run_mode }}

    env:
      AWS_REGION: eu-west-2
      IAM_ROLE_ARN: arn:aws:iam::844815912454:role/GithubActions-Preview-App-Role
      PREEVY_PROFILE_URL: s3://preevy-profile-store?region=eu-west-2
      GH_TOKEN: ${{ secrets.BOT_USER_PAT }}

    steps:
      - uses: actions/checkout@v4
      - run: touch .env # To prevent preevy from failing due to missing .env file

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.IAM_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - run: npm install -g preevy

      - name: Clean up preview environments
        id: cleanup-step
        run: |
          set -euo pipefail

          PROFILE_URL="${{ env.PREEVY_PROFILE_URL }}"
          destroyed_envs="[]"

          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            DRY_RUN="false"
            RUN_MODE="scheduled"
          else
            DRY_RUN="${{ github.event.inputs.dry_run || 'true' }}"
            RUN_MODE="manual"
          fi

          echo "Run mode: $RUN_MODE"
          echo "Dry run: $DRY_RUN"

          REPOS=("trade-tariff-frontend" "trade-tariff-admin")

          envs_json=$(preevy ls --json --profile "$PROFILE_URL") || {
            echo "‚ö†Ô∏è Failed to list environments"
            {
              echo "destroyed_envs=[]"
              echo "dry_run=$DRY_RUN"
              echo "run_mode=$RUN_MODE"
            } >> "$GITHUB_OUTPUT"
            exit 0
          }

          if [[ -z "$envs_json" || "$envs_json" == "null" ]]; then
            echo "‚ö†Ô∏è No environments found"
            {
              echo "destroyed_envs=[]"
              echo "dry_run=$DRY_RUN"
              echo "run_mode=$RUN_MODE"
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          while IFS= read -r env_id; do
            [[ -z "$env_id" || "$env_id" == "null" ]] && continue
            [[ "$env_id" == *keep* ]] && {
              echo "üõë Skipping (excluded by naming): $env_id"
              continue
            }

            # Extract repo type (admin/frontend) and branch name from env_id
            # Format: trade-tariff-<repo>-<branch>
            env_repo=$(echo "$env_id" | sed -E 's/^trade-tariff-(admin|frontend)-.*$/\1/')
            branch_name=$(echo "$env_id" | sed -E 's/^trade-tariff-(admin|frontend)-//')
            branch_name="${branch_name,,}"  # Lowercase

            should_skip="false"
            pr_number=""
            matching_repo="trade-tariff/trade-tariff-$env_repo"  # Only check the matching repo

            echo "üîç Checking $matching_repo for branch: $branch_name"
            for pr in $(gh pr list --repo "$matching_repo" --state open --json number,headRefName -q '.[] | "\(.number)::\(.headRefName)"' || echo ""); do
              number="${pr%%::*}"
              head_branch="${pr##*::}"
              head_branch_lower="${head_branch,,}"

              if [[ "$head_branch_lower" == "$branch_name" ]]; then
                if gh pr view "$number" --repo "$matching_repo" --json labels -q '.labels[].name' | grep -q "^keep-preview$"; then
                  echo "üõë Skipping: $env_id (PR #$number in $matching_repo is labeled keep-preview)"
                  should_skip="true"
                else
                  pr_number="$number"
                fi
                break
              fi
            done

            if [[ "$should_skip" == "true" ]]; then
              continue
            fi

            if [[ "$DRY_RUN" == "true" ]]; then
              echo "‚úÖ [DRY RUN] Would destroy: $env_id"
              destroyed_envs=$(jq -n --argjson arr "$destroyed_envs" --arg id "$env_id" '$arr + [$id + " (DRY RUN)"]')
            else
              echo "üî• Destroying: $env_id"
              if preevy down --id "$env_id" --force --wait --profile "$PROFILE_URL"; then
                destroyed_envs=$(jq -n --argjson arr "$destroyed_envs" --arg id "$env_id" '$arr + [$id]')
                if [[ -n "$pr_number" ]]; then
                  echo "üè∑Ô∏è Removing 'needs-preview' label from PR #$pr_number in $matching_repo"
                  gh pr edit "$pr_number" --repo "$matching_repo" --remove-label "needs-preview" || echo "‚ö†Ô∏è Failed to remove label"
                fi
              else
                echo "‚ùå Failed to destroy: $env_id"
                destroyed_envs=$(jq -n --argjson arr "$destroyed_envs" --arg id "$env_id" '$arr + [$id + " (FAILED)"]')
              fi
            fi
          done < <(echo "$envs_json" | jq -r '.[].envId')

          {
            echo "destroyed_envs=$(jq -c <<< "$destroyed_envs")"
            echo "dry_run=$DRY_RUN"
            echo "run_mode=$RUN_MODE"
          } >> "$GITHUB_OUTPUT"

  notifications:
    if: needs.cleanup.outputs.destroyed_envs != '[]' && needs.cleanup.outputs.dry_run == 'false'
    needs: cleanup
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_CHANNEL: 'deployments'
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_ICON_EMOJI: ':recycle:'
          SLACK_TITLE: 'Preview Cleanup Report'
          SLACK_MESSAGE: |
            *Cleanup completed*
            *Run Mode:* `${{ needs.cleanup.outputs.run_mode }}`
            *Destroyed Environments:*
            ${{ join(fromJson(needs.cleanup.outputs.destroyed_envs), ', ') }}
